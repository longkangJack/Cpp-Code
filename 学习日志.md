#                              学习日志 

比特81班 马龙康 C++_STL_string 第一天日报

1.上课内容总体完成进度: 90%

string类非成员函数 ：5%；

其他:100%

###                                                   第一天

\### 一、STL介绍 >1、STL 有各种版本 > >2、STL 六大组件 【空间配置器、容器、算法、迭代器、容器适配器、仿函数】

一丶STL(standard template libaray-标准模板库)：是C++标准库的重要组成部分，不仅是一个可复用的 .

组件库，而且是一个包罗数据结构与算法的软件框架

### STL的缺陷

1. STL库的更新太慢了。这个得严重吐槽，上一版靠谱是C++98，中间的C++03基本一些修 

​     订。C++11出来已经相隔了13年，STL才进一步更新。 

2. STL现在都没有支持线程安全。并发环境下需要我们自己加锁。且锁的粒度是比较大的。 

3. STL极度的追求效率，导致内部比较复杂。比如类型萃取，迭代器萃取。 

4. STL的使用会有代码膨胀的问题，比如使用vector/vector/vector这样会生成多份代码，当然

二丶string使用

1.string对象的构造

```c++
void main()
{
	string s1; //构造空的string类对象s1；
	string s2("hello bit");//用C格式字符串构造string类对象s2；
	string s3(s2);//拷贝构造s3；
	cout << "s1 = " << s1 << endl;
	cout << "s2 = " << s2 << endl;
	cout << "s3 = " << s3 << endl;
	string s4(10, 'k');//拷贝10个k字符
	cout << "s4 = " << s4 << endl;
    //string(const string &s)
    string s5(s3);
    cout<<"s5 = "<<str5<<endl;

    //string(const string &s)
    string s6 = s5;
    cout<<"s6 = "<<s6<<endl;

}
```

2、  string类对象的容量操作

```c++
size()  length()  capacity()  empty()  clear()  reserve()  resize()

1. size()与length()方法底层实现原理完全相同，引入size()的原因是为了与其他容器的接口保持一
致，一般情况下基本都是用size()。
2. clear()只是将string中有效字符清空，不改变底层空间大小。
3. resize(size_t n) 与 resize(size_t n, char c)都是将字符串中有效字符个数改变到n个，不同的是当字
符个数增多时：resize(n)用0来填充多出的元素空间，resize(size_t n, char c)用字符c来填充多出的
元素空间。注意：resize在改变元素个数时，如果是将元素个数增多，可能会改变底层容量的大
小，如果是将元素个数减少，底层空间总大小不变。
4. reserve(size_t res_arg=0)：为string预留空间，不改变有效元素个数，当reserve的参数小于
string的底层空间总大小时，reserver不会改变容量大小
```

函数名称     功能说明

size()            返回字符串有效字符长度

length          返回字符串有效字符长度

capacity       返回空间总大小

empty         检测字符串是否为空串，是返回true，否则返回false

clear            清空有效字符

reserve       为字符串预留空间

resize         将有效字符的个数改成n个，多出的空间用字符C填充。

使用

```c++
void main()
{
	//string类对象支持cin和cout的直接输出和输出
	string s("hello,bit!!!");
	cout << s.size() << endl;
	cout << s.length() << endl;
	cout << s.capacity() << endl;
	cout << s << endl;
	//s.clear();
	cout << s.size() << endl;
	// 将s中有效字符个数增加到10个，多出位置用'a'进行填充
   // “aaaaaaaaaa”
	s.resize(10, 'a');//有效字符调整到10个,总容量不变
	cout << s.size() << endl;
	cout << s.capacity() << endl;// 将s中有效字符个数缩小到5个
	cout << s << endl;
	/*s.resize(5);
	cout << s.size() << endl;
	cout << s.capacity() << endl;
	cout << s << endl;*/
	// 测试reserve是否会改变string中有效元素个数
	s.reserve(50);
	cout << s.size() << endl;
	cout << s.capacity() << endl;

}
```

3.string类对象的访问及遍历操作

```c++
void main()
{
	string str = "hello world";
	//直接输出
	cout << str << endl;
	//operator
	for (int i = 0; i < str.size(); i++)
	{
		cout << str[i];//str.operator[](i);
		//cout << endl;
	}
	//C++11输出方法
	for (auto ele : str)//引用
	{
		if (ele == 'H')
			ele = 'h';
		cout << ele;
	}
	cout << endl;
	//迭代器 iterator
	string::iterator it = str.begin();
	while (it != str.end())
	{
		cout << *it;
		++it;
	}
	cout << endl;
}
```

4、 string类对象的修改操作

```c++
push_bac()  append()   operator+=()  c_str()  find()  rfind()  substr()
    
    string str;
    str.push_back(' ');   // 在str后插入空格
    str.append("hello");  // 在str后追加一个字符"hello"
    str += 'b';           // 在str后追加一个字符'b'   
    str += "it";          // 在str后追加一个字符串"it"
    cout<<str<<endl;
    cout<<str.c_str()<<endl;   // 以C语言的方式打印字符串  
    // 获取file的后缀
    string file1("string.cpp");
    size_t pos = file.rfind('.');

 

```

5、string类非成员函数

```C++
operator+   尽量少用，因为传值返回，导致深拷贝效率低
operator>> （重点） 输入运算符重载
operator<< （重点） 输出运算符重载
getline    （重点） 获取一行字符串

relational operators （重点)
bool operator== (const string& lhs, const string& rhs);
bool operator== (const char*   lhs, const string& rhs);
bool operator== (const string& lhs, const char*   rhs);
(2)	
bool operator!= (const string& lhs, const string& rhs);
bool operator!= (const char*   lhs, const string& rhs);
bool operator!= (const string& lhs, const char*   rhs);
(3)	
bool operator<  (const string& lhs, const string& rhs);
bool operator<  (const char*   lhs, const string& rhs);
bool operator<  (const string& lhs, const char*   rhs);
(4)	
bool operator<= (const string& lhs, const string& rhs);
bool operator<= (const char*   lhs, const string& rhs);
bool operator<= (const string& lhs, const char*   rhs);
(5)	
bool operator>  (const string& lhs, const string& rhs);
bool operator>  (const char*   lhs, const string& rhs);
bool operator>  (const string& lhs, const char*   rhs);
(6)	
bool operator>= (const string& lhs, const string& rhs);
bool operator>= (const char*   lhs, const string& rhs);
bool operator>= (const string& lhs, const char*   rhs);
```

6.遗留问题:

迭代器理解不是特别清楚;

for (auto ele : str)//引用
	{
		if (ele == 'H')
			ele = 'h';
		cout << ele;
	}

这段代码不是特别理解

3.建议： 无



