## 容器总结

**容器的选择**

 1.强调快速随机访问。则vector要比list好得多 。
 2.已知要存储元素的个数。vector 好于list。 
 3.强调增删且不要在两端插入修改元素。则list显然要比vector好。  
  4.除非我们需要在容器首部插入和删除元素，deque好于vector。因为vector仅仅在尾部增删快速。
  6.如果只需要在读取输入时在容器的中间位置插入元素，然后需要随机访问元素，则可考虑输入时将元素读入到一个List容器，然后排序，然后将排序后的list容器复制到一个vector容器中。
   5.如果只在容易的首部和尾部插入数据元素，则选择deque.

# **容器之间的差异和联系**

  **1.vector** （连续的空间存储,可以使用[]操作符）快速的访问随机的元素，快速的在末尾插入元素，但是在序列中间岁间的插入，删除元素要慢（涉及元素复制移动），而且如果一开始分配的空间不够的话，有一个重新分配更大空间，此时需要拷贝的性能开销。可以快速地在最后添加删除元素,并可以快速地访问任意元素

2.deque   在开始和最后添加删除元素都一样快,并提供了随机访问方法,像vector一样使用[]访问任意元素,但是随机访问速度比不上vector快,因为它要内部处理堆跳转deque也有保留空间.另外,由于deque不要求连续空间,所以可以保存的元素比vector更大,这点也要注意一下.还有就是在前面和后面添加元素时都不需要移动其它块的元素。对deque的排序操作，可将deque先复制到vector，排序后在复制回deque。

​      1)两端都能快速插入元素和删除元素（vector只在尾端快速进行此类操作）。

​     2）存取元素时，deque的内部结构会多一个间接过程，所以元素的存取和迭代器的动作会稍稍慢一些。

​     3）迭代器需要在不同区块间跳转，所以必须是特殊的智能型指针，非一般指针。

​     4）在对内存区块有所限制的系统中（例如PC系统），deque可以内含更多元素，因为它使用不止一块内存。因此deque的max_size()可能更大。

​     5）deque不支持对容量和内存重分配时机的控制。特别要注意的是，除了头尾两端，在任何地方插入或删除元素，都将导致指向deque元素的任何指针、引用、迭代器失效。不过，deque的内存重分配优于vector，因为其内部结构显示，deque不必在内存重分配时复制所有元素。

​     6）deque的内存区块不再被使用时，会被释放。deque的内存大小是可缩减的。

**3.list**（元素间使用链表相连）访问随机元素不如vector快，随机的插入元素比vector快，对每个元素分配空间，所以不存在空间不够，重新分配的情况。list可以快速地在所有地方添加删除元素,但是只能快速地访问最开始与最后的元素

  **4.set** 内部元素唯一，用一棵平衡树结构来存储，因此遍历的时候就排序了，查找比较快。

​     **5.map** 一对一的映射的结合，key不能重复。

​      **6.stack** 适配器，必须结合其他的容器使用，stl中默认的内部容器是deque。先进后出，只有一个出口，不允许遍历。

​      **7.queue** 适配器。是受限制的deque，内部容器一般使用list较简单。先进先出，不允许遍历和元素的随机访问。

​      需要说明的是：由于deque可以从首位两端插入或剔除元素，所以只需要对其进行简单的封装就可以分别实现先进先出（FIFO）的stack和先进后出（FILO）的queue了。stack和queue中都有一个deque类型的成员，用做数据存储的容器，然后对deque的部分接口进行简单的封装，例如stack只提供从末端插入和删除的接口以及获取末端元素的接口，而queue则只提供从尾部插入而从头部删除的接口以及获取首位元素的接口。像这样具有“修改某物接口，形成另一种风貌”的性质的，称为配接器（adapter），因此STL中stack和queue往往不被归类为容器（container），而被归类为容器配接器（container adapter）。

 