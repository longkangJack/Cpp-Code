## 动态内存管理

1.动态内存管理是什么

动态内存管理，是操作系统允许程序员自由开辟地址空间，用户可以自由的申请，释放空间，来存放自己数据，但是用户自己申请的空间要自己来进行释放。它不像数组，静态内存那样，需要在程序运行之前就分配好内存空间。可以在程序运行时根据所需要的内存大小来自由分配。如果用完之后不合理释放，如果申请的过多而不释放，会导致内存空间不足，而导致程序崩溃。
C/C++定义了四个内存区间，分别为代码区，全局变量和静态变量区，局部变量区，即栈区。动态存储区，即堆区。
通常定义变量时，编译器知道这个变量的类型，以及大小。系统在运行时，可以在适当时候为这个变量开启空间。这种分配内存的方式为静态存储分配。有些操作对象需要在运行时期才能确定类型以及大小。这时编译器就不知道要给这个对象创建多大的内存了，开多了浪费空间，开少了不够用，造成越界访问。这时就需要程序在运行时期来为这个对象动态的分配空间，需要多少给多少。这时就有了动态的存储内存的方法。这个方法就叫做动态内存管理。动态分配的空间都在堆上进行。

2.为什么要有动态内存管理

不需要预先分配内存，根据具体对象大小分配。空间的大小可以根据程序的具体需要自行改变所需要内存大小。不会像静态分配那样，分配固定空间，导致的空间浪费以及空间不足等问题，当然除非对象所需空间比较确定。栈的空间比较小。堆的空间比较大。并且一部分空间用完之后可以进行释放，释放之后又可以进行申请，可以重复的使用有限的资源。

3。如何使用动态内存管理

C语言中使用动态开辟内存有三种方法，malloc,calloc,realloc。
malloc原型malloc(size)，开辟size大小的内存空间，返回这块空间的起始地址。类型为void *  需要使用者自行转换这段空间的对象类型。在函数前加上对应类型的强制类型转换。 申请失败会返回一个空指针。所以开辟后使用前先判断是否开辟好空间。
calloc：参数是需要分配的元素个数和每个元素的长度。calloc函数在返回前把内存初始化为0，
realloc函数可以改变一个已经动态分配的内存的大小，增加内存块大小有时可能采取的方法是把原来内存块上的所有数据复制到一个新的更大的内存块上，当一个动态分配的内存块不再使用时，应该调用free函数把它归还给可用内存池，内存释放后便不能再被访问。

```c
p = malloc();
memset(p, 0,size);
```

降低了效率

4.如果请求的内存分配失败，malloc、calloc。realloc函数都将返回的是一个空指针。错误的访问分配内存之外的区域所引起的后果类似越界访问一个数组，但这个错误还能破坏可用内存池，导致程序失败。如果一个指针不是从malloc，calloc，realloc函数返回的，那它不能作为参数传递给free函数的。使用malloc系列内存时要注意以下几点：
对NULL指针进行解引用操作。
对分配的内存进行操作时越过边界。
释放并非动态分配的内存。
试图释放一块动态分配的内存的一部分。
一块内存被释放后被继续的使用。
5.malloc底层，malloc申请内存空间，会在头部申请32个字节，用来保存关于申请出来的这段空间的信息，尾部也会有4个字节用来保护这段内存空间。防止越界。  因此每次调用malloc函数，就会额外申请36个字节的空间用来维护这段空间，此时使用new［］时，如果对象过多。会造成言重的空间浪费情况。会造成内存碎片过多。不容易管理。此时可以引入内存池。 更好的管理内存空间。

6.C++中空间的申请和释放

则使用new  delete  与C语言不同的是。new是关键字并不是函数。 new内部调用的是operator new函数，这个函数内部则调用malloc函数。 new申请的空间需要用delete 来释放。  new [] 申请的 一定要用delete[]来释放，new申请空间需要对象类型，malloc需要空间大小，需要强转类型。new[]申请空间，有多少个对象，就调用多少次对象的构造函数，而且申请出来的对象空间起始位置的前四个字节中，会存放申请空间中对象的个数。在释放时，delete[]会先去看地址空间前四个字节中，当前有多少个对象被创建，然后在内部执行对应次数的delete。来释放这段空间的每一个对象。调用对象的析构函数。 所以new[]出来的对象必须用delete[]来释放。
